<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>jsMind</title>
        <link type="text/css" rel="stylesheet" href="../style/jsmind.css" />
        <style type="text/css">
            body {
                font-family: Arial, sans-serif;
                margin: 0;
                padding: 0;
                background-color: #f5f5f5;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                width: 100%;
                height: 100vh;
                margin: 0;
                background: white;
                display: flex;
                flex-direction: column;
            }
            
            .header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 20px;
                text-align: center;
            }
            
            .header h1 {
                margin: 0;
                font-size: 24px;
            }
            
            .toolbar {
                background: #f8f9fa;
                padding: 10px 15px;
                border-bottom: 1px solid #dee2e6;
                display: flex;
                gap: 10px;
                align-items: center;
                flex-wrap: wrap;
                flex-shrink: 0;
            }
            
            .file-input-wrapper {
                position: relative;
                display: inline-block;
            }
            
            .file-input {
                position: absolute;
                opacity: 0;
                width: 0;
                height: 0;
            }
            
            .file-input-label {
                display: inline-block;
                padding: 8px 16px;
                background: #007bff;
                color: white;
                border-radius: 4px;
                cursor: pointer;
                transition: background-color 0.3s;
                font-size: 14px;
            }
            
            .file-input-label:hover {
                background: #0056b3;
            }
            
            .btn {
                padding: 8px 16px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.3s;
            }
            
            .btn-success {
                background: #28a745;
                color: white;
            }
            
            .btn-success:hover {
                background: #218838;
            }
            
            .btn-warning {
                background: #ffc107;
                color: #212529;
            }
            
            .btn-warning:hover {
                background: #e0a800;
            }
            
            .btn-danger {
                background: #dc3545;
                color: white;
            }
            
            .btn-danger:hover {
                background: #c82333;
            }
            
            .btn-info {
                background: #17a2b8;
                color: white;
            }
            
            .btn-info:hover {
                background: #138496;
            }
            
            .btn-secondary {
                background: #6c757d;
                color: white;
                margin-top: 10px;
            }
            
            .status {
                flex: 1;
                color: #666;
                font-size: 14px;
            }
            
            #jsmind_container {
                width: 100%;
                flex: 1;
                background: #f4f4f4;
                border: none;
                overflow: hidden;
            }
            
            .context-menu {
                position: absolute;
                background: white;
                border: 1px solid #ccc;
                border-radius: 4px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                z-index: 1000;
                min-width: 120px;
                display: none;
            }
            
            .context-menu-item {
                padding: 8px 12px;
                cursor: pointer;
                border-bottom: 1px solid #eee;
                font-size: 14px;
            }
            
            .context-menu-item:last-child {
                border-bottom: none;
            }
            
            .context-menu-item:hover {
                background-color: #f5f5f5;
            }
            
            .context-menu-item.disabled {
                color: #999;
                cursor: not-allowed;
                pointer-events: none;
            }
        </style>
    </head>

    <body>
        <div class="container">

            
            <div class="toolbar">
                <div class="file-input-wrapper">
                    <input type="file" id="xmind-file" class="file-input" accept=".mm,.json" />
                    <label for="xmind-file" class="file-input-label">ğŸ“ é€‰æ‹©æ–‡ä»¶</label>
                </div>
                

                
                <button class="btn btn-success" onclick="loadSampleData()">ğŸ“Š åŠ è½½ç¤ºä¾‹æ•°æ®</button>
                <button class="btn btn-warning" onclick="exportData()">ğŸ’¾ å¯¼å‡ºæ•°æ®</button>
                <button class="btn btn-danger" onclick="clearMap()">ğŸ—‘ï¸æ¸…ç©º</button>
                
                <div class="status" id="status">è¯·é€‰æ‹©æ–‡ä»¶æˆ–åŠ è½½ç¤ºä¾‹æ•°æ®</div>
            </div>
            
            <div id="jsmind_container"></div>
        </div>
        
        <div id="context-menu" class="context-menu">
            <div class="context-menu-item" onclick="addChildNode(event)">â• æ·»åŠ å­èŠ‚ç‚¹</div>
            <div class="context-menu-item" onclick="addSiblingNode(event)">â†—ï¸ æ·»åŠ å…„å¼ŸèŠ‚ç‚¹</div>
            <div class="context-menu-item" onclick="editNode(event)">âœï¸ ç¼–è¾‘èŠ‚ç‚¹</div>
            <div class="context-menu-item" onclick="deleteNode(event)">ğŸ—‘ï¸ åˆ é™¤èŠ‚ç‚¹</div>
        </div>
        
        <script src="../es6/jsmind.js"></script>
        <script src="../es6/jsmind.draggable-node.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        
        <script type="text/javascript">
            let jm;
            let contextMenu;
            let currentNode = null;
            
            function initJsMind() {
                var options = {
                    container: 'jsmind_container',
                    editable: true,
                    theme: 'primary',
                };
                jm = new jsMind(options);
                
                contextMenu = document.getElementById('context-menu');
                
                document.getElementById('jsmind_container').addEventListener('contextmenu', handleContextMenu);
                document.addEventListener('click', function(e) {
                    if (e.target.closest('#context-menu')) {
                        return;
                    }
                    hideContextMenu();
                });
                
                document.getElementById('xmind-file').addEventListener('change', handleFileSelect);
                
                // åˆå§‹åŒ–æ‹–åŠ¨åŠŸèƒ½
                initDragPan();
                
                updateStatus('jsMindåˆå§‹åŒ–å®Œæˆ');
            }
            
            function updateStatus(message, isError = false) {
                const statusElement = document.getElementById('status');
                statusElement.textContent = message;
                statusElement.style.color = isError ? '#dc3545' : '#666';
            }
            
            function handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const fileName = file.name.toLowerCase();
                
                if (fileName.endsWith('.xmind')) {
                    updateStatus('æ­£åœ¨è§£æXmindæ–‡ä»¶...');
                    parseXmindFile(file);
                } else if (fileName.endsWith('.mm')) {
                    updateStatus('æ­£åœ¨è§£æFreeMindæ–‡ä»¶...');
                    parseFreeMindFile(file);
                } else if (fileName.endsWith('.json')) {
                    updateStatus('æ­£åœ¨è§£æJSONæ–‡ä»¶...');
                    parseJsonFile(file);
                } else {
                    updateStatus('è¯·é€‰æ‹©æœ‰æ•ˆçš„æ–‡ä»¶æ ¼å¼ï¼ˆ.mm, .jsonï¼‰', true);
                    return;
                }
            }
            
            async function parseXmindFile(file) {
                try {
                    const zip = new JSZip();
                    const zipContent = await zip.loadAsync(file);
                    
                    // æ˜¾ç¤ºæ–‡ä»¶ç»“æ„ä»¥ä¾¿è°ƒè¯•
                    console.log('Xmindæ–‡ä»¶ç»“æ„ï¼š', Object.keys(zipContent.files));
                    
                    let contentXml = null;
                    let manifestXml = null;
                    
                    // å°è¯•å¤šç§å¯èƒ½çš„å†…å®¹æ–‡ä»¶è·¯å¾„
                    const possibleContentFiles = [
                        'content.xml',
                        'content.json',
                        'Contents/content.xml',
                        'worksheets/sheet1.xml'
                    ];
                    
                    for (const filename of possibleContentFiles) {
                        if (zipContent.files[filename]) {
                            console.log(`æ‰¾åˆ°å†…å®¹æ–‡ä»¶ï¼š${filename}`);
                            if (filename.endsWith('.xml')) {
                                contentXml = await zipContent.files[filename].async('text');
                                break;
                            } else if (filename.endsWith('.json')) {
                                const jsonContent = await zipContent.files[filename].async('text');
                                contentXml = convertJsonToXml(jsonContent);
                                break;
                            }
                        }
                    }
                    
                    // æ£€æŸ¥manifestæ–‡ä»¶è·å–æ ¼å¼ä¿¡æ¯
                    if (zipContent.files['META-INF/manifest.xml']) {
                        manifestXml = await zipContent.files['META-INF/manifest.xml'].async('text');
                        console.log('Manifestä¿¡æ¯ï¼š', manifestXml);
                    }
                    
                    if (!contentXml) {
                        // å¦‚æœæ‰¾ä¸åˆ°å†…å®¹æ–‡ä»¶ï¼Œåˆ—å‡ºæ‰€æœ‰æ–‡ä»¶ä¾›ç”¨æˆ·å‚è€ƒ
                        const fileList = Object.keys(zipContent.files).join(', ');
                        throw new Error(`æ— æ³•æ‰¾åˆ°å†…å®¹æ–‡ä»¶ã€‚æ–‡ä»¶åŒ…å«ï¼š${fileList}`);
                    }
                    
                    console.log('è§£æçš„XMLå†…å®¹ï¼š', contentXml.substring(0, 500) + '...');
                    
                    const mindData = parseXmindXml(contentXml);
                    
                    jm.show(mindData);
                    updateStatus(`æˆåŠŸå¯¼å…¥Xmindæ–‡ä»¶ï¼š${file.name}`);
                    
                } catch (error) {
                    console.error('è§£æXmindæ–‡ä»¶é”™è¯¯ï¼š', error);
                    updateStatus(`è§£æå¤±è´¥ï¼š${error.message}`, true);
                    
                    // æä¾›è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯å’Œå»ºè®®
                    showErrorSuggestions(error.message);
                }
            }
            
            function parseXmindXml(xmlContent) {
                try {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
                    
                    const sheet = xmlDoc.querySelector('sheet');
                    if (!sheet) {
                        throw new Error('æœªæ‰¾åˆ°æœ‰æ•ˆçš„æ€ç»´å¯¼å›¾å†…å®¹');
                    }
                    
                    const rootTopic = sheet.querySelector('topic');
                    if (!rootTopic) {
                        throw new Error('æœªæ‰¾åˆ°æ ¹èŠ‚ç‚¹');
                    }
                    
                    const rootData = parseXmindTopic(rootTopic, true);
                    
                    return {
                        meta: {
                            name: 'Imported from Xmind',
                            author: 'Xmind Import',
                            version: '0.1',
                        },
                        format: 'node_tree',
                        data: rootData,
                    };
                    
                } catch (error) {
                    throw new Error('XMLè§£æå¤±è´¥ï¼š' + error.message);
                }
            }
            
            function parseXmindTopic(topicElement, isRoot = false) {
                const id = topicElement.getAttribute('id') || generateId();
                const title = topicElement.querySelector('title');
                const topic = title ? title.textContent.trim() : 'æœªå‘½åèŠ‚ç‚¹';
                
                const nodeData = {
                    id: id,
                    topic: topic,
                    expanded: true,
                };
                
                const children = [];
                const childTopics = topicElement.querySelector('children topics');
                
                if (childTopics) {
                    const childTopicElements = childTopics.querySelectorAll(':scope > topic');
                    childTopicElements.forEach((childTopic, index) => {
                        const childData = parseXmindTopic(childTopic, false);
                        
                        if (isRoot) {
                            childData.direction = index % 2 === 0 ? 'right' : 'left';
                        }
                        
                        children.push(childData);
                    });
                }
                
                if (children.length > 0) {
                    nodeData.children = children;
                }
                
                return nodeData;
            }
            
            function generateId() {
                return 'node_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }
            
            function convertJsonToXml(jsonContent) {
                // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„JSONåˆ°XMLè½¬æ¢å™¨
                // å®é™…çš„XMind 2020+å¯èƒ½ä½¿ç”¨JSONæ ¼å¼
                try {
                    const data = JSON.parse(jsonContent);
                    console.log('JSONå†…å®¹ï¼š', data);
                    
                    // å°è¯•æ‰¾åˆ°ä¸»è¦çš„æ€ç»´å¯¼å›¾æ•°æ®
                    if (data && data[0] && data[0].rootTopic) {
                        return convertXmindJsonToXml(data[0]);
                    }
                    
                    throw new Error('ä¸æ”¯æŒçš„JSONæ ¼å¼');
                } catch (error) {
                    throw new Error('JSONè§£æå¤±è´¥ï¼š' + error.message);
                }
            }
            
            function convertXmindJsonToXml(jsonData) {
                // å°†XMindçš„JSONæ ¼å¼è½¬æ¢ä¸ºæˆ‘ä»¬èƒ½è§£æçš„XMLæ ¼å¼
                const rootTopic = jsonData.rootTopic;
                
                function buildXmlFromTopic(topic) {
                    let xml = `<topic id="${topic.id || generateId()}">`;
                    xml += `<title>${topic.title || 'Untitled'}</title>`;
                    
                    if (topic.children && topic.children.attached && topic.children.attached.length > 0) {
                        xml += '<children><topics>';
                        topic.children.attached.forEach(child => {
                            xml += buildXmlFromTopic(child);
                        });
                        xml += '</topics></children>';
                    }
                    
                    xml += '</topic>';
                    return xml;
                }
                
                const xmlContent = `<sheet><topic id="${rootTopic.id || 'root'}">
                    <title>${rootTopic.title || 'Root'}</title>
                    ${rootTopic.children && rootTopic.children.attached ? 
                        '<children><topics>' + 
                        rootTopic.children.attached.map(child => buildXmlFromTopic(child)).join('') + 
                        '</topics></children>' : ''}
                </topic></sheet>`;
                
                return xmlContent;
            }
            
            function showErrorSuggestions(errorMessage) {
                const suggestions = document.createElement('div');
                suggestions.className = 'error-suggestions';
                suggestions.innerHTML = `
                    <div class="error-details">
                        <h3>ğŸ“‹ è§£å†³å»ºè®®ï¼š</h3>
                        <ul>
                            <li><strong>ç‰ˆæœ¬å…¼å®¹æ€§</strong>ï¼šè¯·å°è¯•ç”¨XMindå¯¼å‡ºä¸ºè¾ƒè€ç‰ˆæœ¬æ ¼å¼</li>
                            <li><strong>æ›¿ä»£æ–¹æ¡ˆ</strong>ï¼šå¯¼å‡ºä¸ºFreeMind (.mm) æ ¼å¼å†å¯¼å…¥</li>
                            <li><strong>æ–‡æœ¬å¯¼å‡º</strong>ï¼šå¤åˆ¶æ€ç»´å¯¼å›¾å†…å®¹ï¼Œä½¿ç”¨"åŠ è½½ç¤ºä¾‹æ•°æ®"ç„¶åæ‰‹åŠ¨ç¼–è¾‘</li>
                            <li><strong>è°ƒè¯•ä¿¡æ¯</strong>ï¼šæ£€æŸ¥æµè§ˆå™¨æ§åˆ¶å°æŸ¥çœ‹è¯¦ç»†é”™è¯¯</li>
                        </ul>
                        <div class="format-support">
                            <h4>ğŸ“ æ”¯æŒçš„XMindç‰ˆæœ¬ï¼š</h4>
                            <p>â€¢ XMind 8 åŠä»¥ä¸‹ç‰ˆæœ¬ï¼ˆæ¨èï¼‰</p>
                            <p>â€¢ XMind 2020/2021ï¼ˆéƒ¨åˆ†æ”¯æŒï¼‰</p>
                            <p>â€¢ XMind 2022+ï¼ˆå¯èƒ½éœ€è¦å¯¼å‡ºä¸ºæ—§æ ¼å¼ï¼‰</p>
                        </div>
                        <button onclick="this.parentElement.parentElement.remove()" class="btn btn-secondary">å…³é—­</button>
                    </div>
                `;
                
                suggestions.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: white;
                    border: 1px solid #ccc;
                    border-radius: 8px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                    padding: 20px;
                    max-width: 500px;
                    z-index: 10000;
                `;
                
                document.body.appendChild(suggestions);
            }
            
            async function parseFreeMindFile(file) {
                try {
                    const xmlContent = await file.text();
                    const mindData = parseFreeMindXml(xmlContent);
                    jm.show(mindData);
                    updateStatus(`æˆåŠŸå¯¼å…¥FreeMindæ–‡ä»¶ï¼š${file.name}`);
                } catch (error) {
                    console.error('è§£æFreeMindæ–‡ä»¶é”™è¯¯ï¼š', error);
                    updateStatus(`FreeMindè§£æå¤±è´¥ï¼š${error.message}`, true);
                }
            }
            
            async function parseJsonFile(file) {
                try {
                    const jsonContent = await file.text();
                    const data = JSON.parse(jsonContent);
                    
                    // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯jsMindæ ¼å¼
                    if (data.format && (data.format === 'node_tree' || data.format === 'node_array')) {
                        jm.show(data);
                        updateStatus(`æˆåŠŸå¯¼å…¥JSONæ–‡ä»¶ï¼š${file.name}`);
                        return;
                    }
                    
                    // å°è¯•è½¬æ¢å…¶ä»–JSONæ ¼å¼
                    const xmlContent = convertJsonToXml(jsonContent);
                    const mindData = parseXmindXml(xmlContent);
                    jm.show(mindData);
                    updateStatus(`æˆåŠŸå¯¼å…¥JSONæ–‡ä»¶ï¼š${file.name}`);
                } catch (error) {
                    console.error('è§£æJSONæ–‡ä»¶é”™è¯¯ï¼š', error);
                    updateStatus(`JSONè§£æå¤±è´¥ï¼š${error.message}`, true);
                }
            }
            
            function parseFreeMindXml(xmlContent) {
                try {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
                    
                    const rootNode = xmlDoc.querySelector('map > node');
                    if (!rootNode) {
                        throw new Error('æœªæ‰¾åˆ°FreeMindæ ¹èŠ‚ç‚¹');
                    }
                    
                    const rootData = parseFreeMindNode(rootNode, true);
                    
                    return {
                        meta: {
                            name: 'Imported from FreeMind',
                            author: 'FreeMind Import',
                            version: '0.1',
                        },
                        format: 'node_tree',
                        data: rootData,
                    };
                } catch (error) {
                    throw new Error('FreeMind XMLè§£æå¤±è´¥ï¼š' + error.message);
                }
            }
            
            function parseFreeMindNode(nodeElement, isRoot = false) {
                const id = nodeElement.getAttribute('ID') || generateId();
                const text = nodeElement.getAttribute('TEXT') || 'æœªå‘½åèŠ‚ç‚¹';
                const position = nodeElement.getAttribute('POSITION');
                
                const nodeData = {
                    id: id,
                    topic: text,
                    expanded: nodeElement.getAttribute('FOLDED') !== 'true',
                };
                
                // å¤„ç†é¢œè‰²
                const color = nodeElement.getAttribute('COLOR');
                const bgColor = nodeElement.getAttribute('BACKGROUND_COLOR');
                if (color) nodeData['foreground-color'] = color;
                if (bgColor) nodeData['background-color'] = bgColor;
                
                const children = [];
                const childNodes = nodeElement.querySelectorAll(':scope > node');
                
                childNodes.forEach((childNode, index) => {
                    const childData = parseFreeMindNode(childNode, false);
                    
                    if (isRoot) {
                        // FreeMindçš„POSITIONå±æ€§
                        if (position === 'left' || childNode.getAttribute('POSITION') === 'left') {
                            childData.direction = 'left';
                        } else {
                            childData.direction = 'right';
                        }
                        
                        // å¦‚æœæ²¡æœ‰æ˜ç¡®çš„ä½ç½®ï¼Œäº¤æ›¿åˆ†é…
                        if (!childData.direction) {
                            childData.direction = index % 2 === 0 ? 'right' : 'left';
                        }
                    }
                    
                    children.push(childData);
                });
                
                if (children.length > 0) {
                    nodeData.children = children;
                }
                
                return nodeData;
            }
            

            
            function loadSampleData() {
                const sampleData = {
                    meta: {
                        name: 'jsMindç¤ºä¾‹',
                        author: 'jsMind',
                        version: '0.1',
                    },
                    format: 'node_tree',
                    data: {
                        id: 'root',
                        topic: 'é¡¹ç›®ç®¡ç†',
                        expanded: true,
                        children: [
                            {
                                id: 'planning',
                                topic: 'é¡¹ç›®è§„åˆ’',
                                direction: 'right',
                                expanded: true,
                                children: [
                                    { id: 'requirements', topic: 'éœ€æ±‚åˆ†æ' },
                                    { id: 'design', topic: 'ç³»ç»Ÿè®¾è®¡' },
                                    { id: 'timeline', topic: 'æ—¶é—´è§„åˆ’' }
                                ]
                            },
                            {
                                id: 'development',
                                topic: 'å¼€å‘é˜¶æ®µ',
                                direction: 'right',
                                expanded: true,
                                children: [
                                    { id: 'frontend', topic: 'å‰ç«¯å¼€å‘' },
                                    { id: 'backend', topic: 'åç«¯å¼€å‘' },
                                    { id: 'testing', topic: 'æµ‹è¯•' }
                                ]
                            },
                            {
                                id: 'team',
                                topic: 'å›¢é˜Ÿç®¡ç†',
                                direction: 'left',
                                expanded: true,
                                children: [
                                    { id: 'communication', topic: 'æ²Ÿé€šåè°ƒ' },
                                    { id: 'resources', topic: 'èµ„æºåˆ†é…' },
                                    { id: 'monitoring', topic: 'è¿›åº¦ç›‘æ§' }
                                ]
                            }
                        ]
                    }
                };
                
                jm.show(sampleData);
                updateStatus('å·²åŠ è½½ç¤ºä¾‹æ•°æ®');
            }
            
            function exportData() {
                const data = jm.get_data('node_tree');
                const dataStr = JSON.stringify(data, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = 'mindmap_export.json';
                link.click();
                
                updateStatus('æ•°æ®å·²å¯¼å‡ºä¸ºJSONæ–‡ä»¶');
            }
            
            function clearMap() {
                if (confirm('ç¡®å®šè¦æ¸…ç©ºå½“å‰æ€ç»´å¯¼å›¾å—ï¼Ÿ')) {
                    const emptyData = {
                        meta: { name: 'æ–°æ€ç»´å¯¼å›¾', author: 'jsMind', version: '0.1' },
                        format: 'node_tree',
                        data: { id: 'root', topic: 'ä¸­å¿ƒä¸»é¢˜', expanded: true }
                    };
                    jm.show(emptyData);
                    updateStatus('å·²æ¸…ç©ºæ€ç»´å¯¼å›¾');
                }
            }
            
            function handleContextMenu(e) {
                e.preventDefault();
                
                let target = e.target;
                while (target && target !== document.getElementById('jsmind_container')) {
                    if (target.tagName && target.tagName.toLowerCase() === 'jmnode') {
                        let nodeId = target.getAttribute('nodeid');
                        if (nodeId) {
                            currentNode = jm.get_node(nodeId);
                            showContextMenu(e.pageX, e.pageY);
                            return;
                        }
                    }
                    target = target.parentElement;
                }
                
                hideContextMenu();
            }
            
            function showContextMenu(x, y) {
                if (!currentNode) return;
                
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                contextMenu.style.display = 'block';
                
                updateMenuItems();
            }
            
            function updateMenuItems() {
                const items = contextMenu.querySelectorAll('.context-menu-item');
                
                items.forEach(item => {
                    item.classList.remove('disabled');
                });
                
                if (currentNode && currentNode.isroot) {
                    items[1].classList.add('disabled');
                    items[3].classList.add('disabled');
                }
            }
            
            function hideContextMenu() {
                contextMenu.style.display = 'none';
                currentNode = null;
            }
            
            function addChildNode(e) {
                if (e) {
                    e.stopPropagation();
                    e.preventDefault();
                }
                
                const targetNode = currentNode;
                if (!targetNode) {
                    hideContextMenu();
                    return;
                }
                
                hideContextMenu();
                
                try {
                    const nodeId = generateId();
                    const newNode = jm.add_node(targetNode, nodeId, 'æ–°èŠ‚ç‚¹');
                    if (newNode) {
                        jm.select_node(nodeId);
                        setTimeout(() => {
                            jm.begin_edit(nodeId);
                        }, 100);
                    }
                } catch (error) {
                    console.error('æ·»åŠ å­èŠ‚ç‚¹é”™è¯¯ï¼š', error);
                }
            }
            
            function addSiblingNode(e) {
                if (e) {
                    e.stopPropagation();
                    e.preventDefault();
                }
                
                const targetNode = currentNode;
                if (!targetNode || targetNode.isroot) {
                    hideContextMenu();
                    return;
                }
                
                hideContextMenu();
                
                try {
                    const nodeId = generateId();
                    const newNode = jm.insert_node_after(targetNode, nodeId, 'æ–°èŠ‚ç‚¹');
                    if (newNode) {
                        jm.select_node(nodeId);
                        setTimeout(() => {
                            jm.begin_edit(nodeId);
                        }, 100);
                    }
                } catch (error) {
                    console.error('æ·»åŠ å…„å¼ŸèŠ‚ç‚¹é”™è¯¯ï¼š', error);
                }
            }
            
            function editNode(e) {
                if (e) {
                    e.stopPropagation();
                    e.preventDefault();
                }
                
                const targetNode = currentNode;
                if (!targetNode) {
                    hideContextMenu();
                    return;
                }
                
                hideContextMenu();
                
                try {
                    jm.select_node(targetNode.id);
                    jm.begin_edit(targetNode.id);
                } catch (error) {
                    console.error('ç¼–è¾‘èŠ‚ç‚¹é”™è¯¯ï¼š', error);
                }
            }
            
            function deleteNode(e) {
                if (e) {
                    e.stopPropagation();
                    e.preventDefault();
                }
                
                const targetNode = currentNode;
                if (!targetNode || targetNode.isroot) {
                    hideContextMenu();
                    return;
                }
                
                hideContextMenu();
                
                if (confirm('ç¡®å®šè¦åˆ é™¤èŠ‚ç‚¹ "' + targetNode.topic + '" å—ï¼Ÿ')) {
                    try {
                        jm.remove_node(targetNode.id);
                    } catch (error) {
                        console.error('åˆ é™¤èŠ‚ç‚¹é”™è¯¯ï¼š', error);
                    }
                }
            }
            
            // æ‹–åŠ¨åŠŸèƒ½å®ç°
            let isDragging = false;
            let spacePressed = false;
            let dragStartX = 0;
            let dragStartY = 0;
            let lastPanX = 0;
            let lastPanY = 0;
            
            function initDragPan() {
                const container = document.getElementById('jsmind_container');
                
                // ç›‘å¬ç©ºæ ¼é”®
                document.addEventListener('keydown', function(e) {
                    if (e.code === 'Space' && !spacePressed) {
                        e.preventDefault();
                        spacePressed = true;
                        container.style.cursor = 'grab';
                    }
                });
                
                document.addEventListener('keyup', function(e) {
                    if (e.code === 'Space') {
                        spacePressed = false;
                        isDragging = false;
                        container.style.cursor = '';
                    }
                });
                
                // ç›‘å¬é¼ æ ‡äº‹ä»¶
                container.addEventListener('mousedown', function(e) {
                    if (spacePressed && e.button === 0) { // å·¦é”®
                        e.preventDefault();
                        isDragging = true;
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                        container.style.cursor = 'grabbing';
                    }
                });
                
                container.addEventListener('mousemove', function(e) {
                    if (isDragging && spacePressed) {
                        e.preventDefault();
                        
                        const deltaX = e.clientX - dragStartX;
                        const deltaY = e.clientY - dragStartY;
                        
                        // æ›´æ–°æ‹–åŠ¨ä½ç½®
                        lastPanX += deltaX;
                        lastPanY += deltaY;
                        
                        // åº”ç”¨å˜æ¢
                        const mindContainer = container.querySelector('svg') || container.querySelector('.jsmind-inner');
                        if (mindContainer) {
                            mindContainer.style.transform = `translate(${lastPanX}px, ${lastPanY}px)`;
                        }
                        
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                    }
                });
                
                container.addEventListener('mouseup', function(e) {
                    if (isDragging) {
                        isDragging = false;
                        if (spacePressed) {
                            container.style.cursor = 'grab';
                        } else {
                            container.style.cursor = '';
                        }
                    }
                });
                
                // é˜²æ­¢é€‰ä¸­æ–‡æœ¬
                container.addEventListener('selectstart', function(e) {
                    if (spacePressed) {
                        e.preventDefault();
                    }
                });
                
                // å¤±å»ç„¦ç‚¹æ—¶é‡ç½®çŠ¶æ€
                window.addEventListener('blur', function() {
                    spacePressed = false;
                    isDragging = false;
                    container.style.cursor = '';
                });
            }
            
            window.addEventListener('load', initJsMind);
        </script>
    </body>
</html> 